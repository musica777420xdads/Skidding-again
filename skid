-- Enhanced Level-Based Dungeon Autofarm Script
-- Automatically farms dungeons based on level AND manages magic items
-- Features: Auto equip best magic items, delete duplicates, level-based dungeon switching

repeat
    task.wait()
until game:IsLoaded()
    and game.Players.LocalPlayer
    and game.Players.LocalPlayer.Character
    and game.Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart')

task.wait(3)

-- Services
local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local TweenService = game:GetService('TweenService')
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')

local player = Players.LocalPlayer

-- Wait for leaderstats
repeat
    task.wait()
until player:FindFirstChild('leaderstats')
    and player.leaderstats:FindFirstChild('Level')

local playerLevel = player.leaderstats.Level.Value
print('Player Level:', playerLevel)

-- ========================================
-- AUTO EQUIP & DELETE MAGIC ITEMS SYSTEM
-- ========================================

-- Function to check if item has desired stats
local function hasDesiredStats(item)
    local stats = item:FindFirstChild("Stats")
    if not stats then
        return false
    end
    
    -- Check for any of the desired stats
    local desiredStats = {"ATK", "CDRATE", "CRITMDG"}
    for _, statName in pairs(desiredStats) do
        if stats:FindFirstChild(statName) then
            return true, statName -- Return true and which stat it has
        end
    end
    
    return false
end

-- Function to equip item
local function equipItem(item, slot)
    local args = {
        slot or "Right", -- Default to Right slot
        item
    }
    
    local success, error = pcall(function()
        ReplicatedStorage
            :WaitForChild("Systems")
            :WaitForChild("Equipment")
            :WaitForChild("Equip")
            :FireServer(unpack(args))
    end)
    
    if success then
        print("âœ… Equipped: " .. item.Name .. " to " .. (slot or "Right") .. " slot")
        return true
    else
        print("âŒ Failed to equip " .. item.Name .. ": " .. tostring(error))
        return false
    end
end

-- Function to delete items
local function deleteItems(itemsToDelete)
    if #itemsToDelete == 0 then
        return
    end
    
    local success, error = pcall(function()
        ReplicatedStorage
            :WaitForChild("Systems")
            :WaitForChild("ItemSelling")
            :WaitForChild("SellItem")
            :FireServer(itemsToDelete, {})
    end)
    
    if success then
        print("ðŸ—‘ï¸ Deleted " .. #itemsToDelete .. " items")
        for _, item in pairs(itemsToDelete) do
            print("   â””â”€ Deleted: " .. item.Name)
        end
    else
        print("âŒ Failed to delete items: " .. tostring(error))
    end
end

-- Main auto equip function
local function autoEquipAndDeleteItems()
    -- Wait for PlayerGui and Profile to load
    if not player:FindFirstChild("PlayerGui") or not player.PlayerGui:FindFirstChild("Profile") then
        print("âš ï¸ Profile not loaded, skipping item management")
        return
    end

    local profile = player.PlayerGui.Profile
    local inventory = profile:FindFirstChild("Inventory")

    if not inventory then
        print("âš ï¸ Inventory not accessible, skipping item management")
        return
    end

    print("ðŸ” Searching for items with MAGIC/CDRATE/CRITMDG stats...")

    local magicItems = {}
    local bestItem = nil
    local bestItemValue = 0

    -- Scan inventory for items with desired stats
    for _, item in pairs(inventory:GetChildren()) do
        -- Skip UI elements
        if item.ClassName ~= "UIListLayout" 
           and item.ClassName ~= "UIPadding" 
           and item.ClassName ~= "UICorner" 
           and item.ClassName ~= "UIStroke" then
            
            local hasStats, statType = hasDesiredStats(item)
            if hasStats then
                table.insert(magicItems, item)
                print("âœ¨ Found magic item: " .. item.Name .. " (has " .. statType .. ")")
                
                -- Try to determine "best" item
                local level = item:FindFirstChild("Level")
                local rarity = item:FindFirstChild("Rarity")
                
                local itemValue = 0
                if level then itemValue = itemValue + (level.Value or 0) end
                if rarity then itemValue = itemValue + (rarity.Value or 0) * 10 end
                
                if itemValue > bestItemValue then
                    bestItemValue = itemValue
                    bestItem = item
                end
            end
        end
    end

    if #magicItems == 0 then
        print("â„¹ï¸ No magic items found to manage")
        return
    elseif #magicItems == 1 then
        print("ðŸŽ¯ Only one magic item found, equipping it...")
        equipItem(magicItems[1])
        return
    end

    -- Equip the best item and delete the rest
    if bestItem then
        print("âš”ï¸ Best item selected: " .. bestItem.Name .. " (value: " .. bestItemValue .. ")")
        
        local equipped = equipItem(bestItem)
        
        if equipped then
            -- Remove best item from the list so it doesn't get deleted
            for i, item in pairs(magicItems) do
                if item == bestItem then
                    table.remove(magicItems, i)
                    break
                end
            end
            
            -- Delete remaining items
            if #magicItems > 0 then
                print("ðŸ—‘ï¸ Deleting remaining " .. #magicItems .. " magic items...")
                task.wait(1)
                deleteItems(magicItems)
            end
        end
    end
end

-- ========================================
-- DUNGEON FARMING SYSTEM
-- ========================================

-- Level-based dungeon configuration
local function getDungeonConfig(level)
    if level >= 0 and level <= 14 then
        return { 'ForestDungeon', 4, 1, false, false } -- Forest 0-14
    elseif level >= 15 and level <= 29 then
        return { 'MountainDungeon', 4, 1, false, false } -- Orion 15-29 (Mountain)
    elseif level >= 30 and level <= 44 then
        return { 'CaveDungeon', 4, 1, false, false } -- Cave 30-44
    elseif level >= 45 and level <= 59 then
        return { 'CastleDungeon', 4, 1, false, false } -- Castle 45-59
    elseif level >= 60 and level <= 74 then
        return { 'JungleDungeon', 4, 1, false, false } -- Jungle 60-74
    elseif level >= 75 and level <= 89 then
        return { 'AstralDungeon', 4, 1, false, false } -- Astral 75-89
    elseif level >= 90 and level <= 104 then
        return { 'DesertDungeon', 4, 1, false, false } -- Desert 90-104
    elseif level >= 105 and level <= 119 then
        return { 'CaveDungeon', 4, 1, false, false } -- Cave Dungeon 105-119
    elseif level >= 120 and level <= 134 then
        return { 'MushroomDungeon', 4, 1, false, false } -- Mushroom 120-134
    elseif level >= 135 then
        return { 'GoldDungeon', 4, 1, false, false } -- Gold 135+
    else
        return { 'ForestDungeon', 4, 1, false, false } -- Default fallback
    end
end

-- Get dungeon configuration based on current level
local dungeonArgs = getDungeonConfig(playerLevel)
print('Selected Dungeon:', dungeonArgs[1], '| Difficulty:', dungeonArgs[2])

-- Get current dungeon name from PlaceId
local function getCurrentDungeon()
    local placeId = tostring(game.PlaceId)

    -- Check PlaceId to determine current dungeon
    if placeId == '81734311524009' then
        return 'ForestDungeon'
    elseif placeId == '137618699134093' then
        return 'CoveDungeon' -- Pirate Cove
    elseif placeId == '73902695042860' then
        return 'MountainDungeon' -- Orion (Second island)
    elseif placeId == '126046773825086' then
        return 'CaveDungeon' -- Shimmering
    elseif placeId == '99288631985906' then
        return 'CastleDungeon'
    elseif placeId == '135364962469129' then
        return 'JungleDungeon'
    elseif placeId == '71150884252164' then
        return 'DesertDungeon'
    elseif placeId == '137506446187082' then
        return 'MushroomDungeon'
    elseif placeId == '109839406390472' then
        return 'AstralDungeon'
    elseif placeId == '122372710407259' then
        return 'GoldDungeon'
    elseif placeId == '94845773826960' then
        return nil -- Lobby
    else
        return 'Unknown'
    end
end

-- Enter the appropriate dungeon
local function enterDungeon()
    ReplicatedStorage
        :WaitForChild('Systems')
        :WaitForChild('Parties')
        :WaitForChild('SetSettings')
        :FireServer(unpack(dungeonArgs))
    print('Entered dungeon:', dungeonArgs[1])
end

-- Return to lobby function
local function returnToLobby()
    ReplicatedStorage
        :WaitForChild('Systems')
        :WaitForChild('Dungeons')
        :WaitForChild('ExitDungeon')
        :FireServer()
    print('Returned to lobby')
end

-- Kill Aura functionality
local killAuraRunning = true
local function startKillAura()
    task.spawn(function()
        local enemies = Workspace:FindFirstChild('Mobs')
        local delay = 0.22

        while killAuraRunning do
            if enemies then
                local mobs = {}
                for _, v in ipairs(enemies:GetChildren()) do
                    table.insert(mobs, v)
                end

                ReplicatedStorage
                    :WaitForChild('Systems')
                    :WaitForChild('Combat')
                    :WaitForChild('PlayerAttack')
                    :FireServer(mobs)
            end
            task.wait(delay)
        end
    end)
end

-- Auto Start functionality
local autoStartRunning = true
local function startAutoStart()
    task.spawn(function()
        while autoStartRunning do
            ReplicatedStorage
                :WaitForChild('Systems')
                :WaitForChild('Dungeons')
                :WaitForChild('TriggerStartDungeon')
                :FireServer()
            task.wait(0.2)
        end
    end)
end

-- Enhanced Auto Play Again functionality with item management
local autoPlayAgainRunning = true
local itemManagementCounter = 0
local function startAutoPlayAgain()
    task.spawn(function()
        while autoPlayAgainRunning do
            local args = { 'GoAgain' }
            ReplicatedStorage
                :WaitForChild('Systems')
                :WaitForChild('Dungeons')
                :WaitForChild('SetExitChoice')
                :FireServer(unpack(args))

            -- Wait a bit for the exit to process
            task.wait(3)

            -- Item management every 3 dungeon completions
            itemManagementCounter = itemManagementCounter + 1
            if itemManagementCounter >= 3 then
                print("ðŸŽ’ Running item management cycle...")
                autoEquipAndDeleteItems()
                itemManagementCounter = 0
            end

            -- Check current level and get new dungeon config
            local currentLevel = player.leaderstats.Level.Value
            local newDungeonArgs = getDungeonConfig(currentLevel)

            -- Check if we need to switch dungeons
            local currentDungeon = getCurrentDungeon()

            if currentDungeon == newDungeonArgs[1] then
                -- Already in the correct dungeon for new level
                print('Level', currentLevel, '- Already in correct dungeon:', currentDungeon)
                dungeonArgs = newDungeonArgs
            elseif newDungeonArgs[1] ~= dungeonArgs[1] then
                -- Level changed and need different dungeon
                print('Level changed! Current dungeon:', currentDungeon or 'Unknown')
                print('New level:', currentLevel, '| Target dungeon:', newDungeonArgs[1])

                print('Switching dungeons...')

                -- Exit to lobby first if in a dungeon
                if currentDungeon ~= nil then
                    print('Exiting current dungeon...')
                    returnToLobby()
                    task.wait(5)
                end

                dungeonArgs = newDungeonArgs

                -- Enter the new appropriate dungeon
                ReplicatedStorage
                    :WaitForChild('Systems')
                    :WaitForChild('Parties')
                    :WaitForChild('SetSettings')
                    :FireServer(unpack(dungeonArgs))
                print('Entered new dungeon:', dungeonArgs[1])
                task.wait(3)
            else
                -- Same level range, same dungeon - keep farming
                print('Level', currentLevel, '- Continuing in', dungeonArgs[1])
            end

            task.wait(6) -- Wait before next cycle
        end
    end)
end

-- Auto Farm Dungeon functionality
local autoFarmRunning = true
local tweenSpeed = 190
local yOffset = 50

local function getClosestMob()
    local mob = nil
    local distance = math.huge
    local enemies = Workspace:FindFirstChild('Mobs')

    if not enemies then
        return nil
    end

    for _, v in pairs(enemies:GetChildren()) do
        if
            not v:GetAttribute('Owner')
            and v:GetAttribute('HP')
            and v:GetAttribute('HP') > 0
            and v.Name ~= 'Side Room Rune Disabled'
            and v.Name ~= 'TargetDummy'
        then
            local dist = (
                v:GetPivot().Position - player.Character:GetPivot().Position
            ).Magnitude
            if dist < distance then
                distance = dist
                mob = v
            end
        end
    end

    return mob
end

local function startAutoFarm()
    task.spawn(function()
        while autoFarmRunning do
            local mob = getClosestMob()
            if mob then
                task.wait(0.2)

                local velocityConnection = RunService.Heartbeat:Connect(
                    function()
                        if
                            player.Character
                            and player.Character:FindFirstChild('HumanoidRootPart')
                        then
                            player.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
                            player.Character.HumanoidRootPart.AssemblyAngularVelocity = Vector3.zero
                        end
                    end
                )

                local character = player.Character
                local hrp = character and character:FindFirstChild('HumanoidRootPart')

                if hrp and mob then
                    local to = mob:GetPivot().Position
                    local distance = (to - hrp.Position).Magnitude
                    local tween = TweenService:Create(
                        hrp,
                        TweenInfo.new(
                            distance / tweenSpeed,
                            Enum.EasingStyle.Linear,
                            Enum.EasingDirection.Out
                        ),
                        {
                            CFrame = CFrame.new(to + Vector3.new(0, yOffset, 0)),
                        }
                    )
                    tween:Play()
                    tween.Completed:Wait()
                end

                if velocityConnection then
                    velocityConnection:Disconnect()
                end
            end
            task.wait()
        end
    end)
end

-- ========================================
-- ANTI-AFK SYSTEM
-- ========================================

-- Anti-AFK functionality
local antiAfkRunning = true
local function startAntiAfk()
    task.spawn(function()
        local VirtualUser = game:GetService('VirtualUser')
        
        while antiAfkRunning do
            -- Simulate player activity to prevent AFK kick
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
            
            print('ðŸ”„ Anti-AFK activated')
            task.wait(10) -- Check every 10 seconds
        end
    end)
end

-- ========================================
-- MAIN EXECUTION
-- ========================================

print('ðŸš€ Starting Enhanced Level-Based Autofarm with Item Management...')
print('Target Dungeon:', dungeonArgs[1])

-- Initial item management
print('ðŸŽ’ Running initial item management...')
autoEquipAndDeleteItems()

-- Check if already in correct dungeon by PlaceId
local currentDungeon = getCurrentDungeon()
local targetDungeon = dungeonArgs[1]

if currentDungeon == targetDungeon then
    print('Already in correct dungeon! PlaceId matches target:', targetDungeon)
    print('Skipping dungeon entry, starting farm...')
elseif currentDungeon == nil then
    print('In lobby, entering dungeon:', targetDungeon)
    enterDungeon()
    task.wait(2)
else
    print('In wrong dungeon! Current:', currentDungeon, '| Target:', targetDungeon)
    print('Exiting and entering correct dungeon...')
    returnToLobby()
    task.wait(5)
    enterDungeon()
    task.wait(2)
end

-- Start all automation
startKillAura()
startAutoStart()
startAutoPlayAgain()
startAutoFarm()
startAntiAfk()

print('âœ… Enhanced Autofarm started successfully!')
print('Kill Aura: ON')
print('Auto Start: ON')
print('Auto Play Again: ON')
print('Auto Farm Dungeon: ON')
print('Auto Item Management: ON (every 3 dungeon completions)')
print('Anti-AFK: ON')

-- Optional: Stop functions (for manual control)
--[[
To stop the farm, you can set these to false:
killAuraRunning = false
autoStartRunning = false
autoPlayAgainRunning = false
autoFarmRunning = false
antiAfkRunning = false
--]]
